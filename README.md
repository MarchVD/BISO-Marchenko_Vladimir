# Отчет по практической работе
## «Основы Git и визуализация кода на Go с помощью PlantUML»

**Студент:** Марченко Владимир
**Группа:** БИСО-03-23
**Дата:** 14.02.2026

### 1. Используемые технологии
- **Git** — система контроля версий.
- **GitHub** — удаленный репозиторий.
- **PlantUML** — инструмент для создания UML-диаграмм.
- **Go** — язык программирования.

### 2. Выполненные задания

#### Этап 1: Создание Git-репозитория
Были выполнены следующие команды:
*   `git clone` — клонирование репозитория.
*   `git add .` — добавление файлов в staging area.
*   `git commit -m "Initial commit"` — создание первого коммита.

#### Этап 2: PlantUML и код на Go
Разработана диаграмма классов, описывающая паттерн "Стратегия" (или "Инъекция зависимости") для отправки уведомлений.

### 3. Ответы на контрольные вопросы

#### 1. Для чего нужна команда `git init, git clone`?
Команда git init — инициализирует новый локальный репозиторий Git в текущей папке.
Команда git clone — создает локальную копию удаленного репозитория Git.

#### 2. Что такое "коммит"?
Коммит (commit) — это, «снимок» (snapshot) состояния проекта в определенный момент времени. Коммит содержит информацию:
1. Автор: Имя человека, создавшего изменения.
2. Дата: Время создания коммита.
3. Сообщение: Краткое описание коммита.
4. Снимок файлов: Состояние всех отслеживаемых файлов на момент коммита.

#### 3. Чем отличаются файлы `.puml` от `.png` в контексте вашей работы?
Файл `.puml` — это текстовый код диаграммы с инструкциями, описывающими сущности и связи. Файл `.png` — конечное изображение составленное на основе `.puml`. Лучше всего хранить файл `.puml`, так как git может отслеживать все его текстовые изменения. Файл `.png` можно в любой момент сгенерировать из `.puml`, и нужен только для наглядного представления в документации.

#### 4. Объясните, как в коде Go реализуется связь "класс User использует интерфейс Notifier", показанная на диаграмме.
Cвязь «класс User использует интерфейс Notifier» реализована через паттерн "Инъекция зависимостей".
Интерфейс:
```go
// Notifier определяет интерфейс для отправки уведомлений.
type Notifier interface {
	Send(message string) error
}
```
Реализация:
1. EmailNotifier:
```go
// Send реализует интерфейс Notifier для EmailNotifier.
func (e EmailNotifier) Send(message string) error {
	fmt.Printf("Sending email via %s:%d: %s\n", e.smtpHost, e.smtpPort, message)
	// Здесь была бы реальная отправка email
	return nil
}
```
2. SmsNotifier:
```go
// Send реализует интерфейс Notifier для SmsNotifier.
func (s SmsNotifier) Send(message string) error {
	fmt.Printf("Sending SMS to %s using API key %s: %s\n", s.phoneNumber, s.apiKey, message)
	// Здесь была бы реальная отправка SMS
	return nil
}
```
`User` получает нужную реализацию через поле `notifier`:
```go
// UserMarchenkoVladimir представляет пользователя, который может получать уведомления.
type UserMarchenkoVladimir struct {
	name     string
	email    string
	notifier Notifier // Зависимость от интерфейса (инъекция зависимости)
}
```
Преимущества такого подхода:
1. Слабая связанность — `User` не зависит от конкретных типов уведомлений.
2. Легкость расширения — можно добавить новый способ уведомления, не меняя код `User`.
